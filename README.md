# CI2025_lab3



### Behavior with negative edge weights

- **Step 1 – Dijkstra & A\***  
  I first tested Dijkstra and A\* on a subset of parameter settings.  
  For graphs with non-negative edge weights, both algorithms returned valid shortest paths.

- **Step 2 – Switch to Bellman–Ford**  
  When negative edge values appeared, Dijkstra and A\* could no longer be applied, so I switched to the Bellman–Ford algorithm for those instances.

- **Step 3 – Negative cycles**  
  On some generated graphs, Bellman–Ford detects negative cycles.  
  From a mathematical perspective, this implies that no well-defined shortest path exists between source and target: the algorithm could traverse the negative cycle infinitely many times, pushing the path cost towards infinity.  
  In these cases, the instance is classified as “no shortest path (negative cycle)”.

### Handwritten Dijkstra

I also implemented a simple handwritten version of Dijkstra's algorithm, and used it on top of the cost matrices generated by `create_problem(...)`.

The main functions are:

- `dijkstra(n, adj, source)`  
  Single-source shortest paths on an adjacency list.  
  - `n`: number of nodes (0..n-1)  
  - `adj`: adjacency list, where `adj[u]` is a list of `(v, w)` edges `u -> v`  
  - `source`: source node  
  Returns `(dist, prev)`, where `dist[v]` is the distance from `source` to `v` (or `math.inf` if unreachable), and `prev[v]` stores the predecessor of `v`. All edge weights `w` must be non-negative.

- `reconstruct_path(prev, s, t)`  
  Rebuilds the path `s -> t` using the `prev` array returned by `dijkstra`.  
  Returns a list of nodes, or `None` if `t` is unreachable.

- `matrix_to_adj(cost_matrix)`  
  Converts the `numpy` cost matrix produced by `create_problem(...)` (with `np.inf` meaning “no edge”) into the adjacency list format required by `dijkstra`.

- `all_pairs_dijkstra_with_handwritten(problem)`  
  Runs the handwritten Dijkstra from every node as source on the given cost matrix `problem`, and returns a list of tuples `(s, t, path, cost)` for all `0 <= s < t < n`.

Example usage:

```python
problem = create_problem(
    size=10,
    density=0.5,
    noise_level=0.0,
    negative_values=False,  # must be non-negative for Dijkstra
    seed=42,
)
```

results = all_pairs_dijkstra_with_handwritten(problem)



### Handwritten A\*

I also implemented a simple handwritten version of the A\* algorithm, using the same cost matrices generated by `create_problem(...)`.

The main functions are:

- `astar(n, adj, source, target, h)`  
  Single-pair shortest path with A\* on an adjacency list.  
  - `n`: number of nodes (0..n-1)  
  - `adj`: adjacency list, where `adj[u]` is a list of `(v, w)` edges `u -> v`  
  - `source`, `target`: start and goal nodes  
  - `h`: heuristic function `h(u, target)`  
  Returns `(dist, prev)`, where `dist[v]` is the g-cost from `source` to `v`, and `prev[v]` stores the predecessor of `v`. All edge weights `w` are required to be non-negative.

- `astar_from_problem(problem, coords, s, t)`  
  Convenience wrapper that:
  1. converts the cost matrix `problem` into an adjacency list using `matrix_to_adj(...)`,  
  2. defines a Euclidean-distance heuristic based on `coords` (the node coordinates returned by `get_coords(...)`),  
  3. runs `astar(...)` and returns the `(path, cost)` from node `s` to node `t`.

It is used on the same graphs as Dijkstra (with `negative_values=False`), and the results have been checked against `networkx.astar_path` for correctness.



### Performance: handwritten vs NetworkX

I benchmarked my handwritten implementations against NetworkX on graphs
generated by `create_problem(...)`, using the same cost matrices and
the same random seed.

#### Dijkstra (`dijkstra` vs NetworkX)

- Distances from `dijkstra(...)` exactly match NetworkX  
  (`max_abs_diff = 0` in all tested configurations).
- In these experiments, the handwritten `dijkstra` is slightly faster:
  for example:

  ```text
  size=10, density=0.2: my_time ≈ 0.01–0.10 ms,  nx_time ≈ 0.03–1.18 ms
  size=50, density=0.8: my_time ≈ 0.49 ms,       nx_time ≈ 1.43 ms


- A* (astar_from_problem vs NetworkX)
Paths and costs match exactly (path_match = True, cost_diff = 0).
However, the handwritten A* is slower than NetworkX on larger graphs.
For example:
```text
size=50: my_time ≈ 1.2–1.7 ms,   nx_time ≈ 0.07–0.11 ms
size=100: my_time ≈ 3.4–4.1 ms,  nx_time ≈ 0.06–0.12 ms

So, the handwritten implementations are correct and useful to
understand the algorithms, while NetworkX remains more efficient
for larger instances, especially for A*.
