# CI2025_lab3



### Behavior with negative edge weights

- **Step 1 – Dijkstra & A\***  
  I first tested Dijkstra and A\* on a subset of parameter settings.  
  For graphs with non-negative edge weights, both algorithms returned valid shortest paths.

- **Step 2 – Switch to Bellman–Ford**  
  When negative edge values appeared, Dijkstra and A\* could no longer be applied, so I switched to the Bellman–Ford algorithm for those instances.

- **Step 3 – Negative cycles**  
  On some generated graphs, Bellman–Ford detects negative cycles.  
  From a mathematical perspective, this implies that no well-defined shortest path exists between source and target: the algorithm could traverse the negative cycle infinitely many times, pushing the path cost towards infinity.  
  In these cases, the instance is classified as “no shortest path (negative cycle)”.

### Handwritten Dijkstra

I also implemented a simple handwritten version of Dijkstra's algorithm, and used it on top of the cost matrices generated by `create_problem(...)`.

The main functions are:

- `dijkstra(n, adj, source)`  
  Single-source shortest paths on an adjacency list.  
  - `n`: number of nodes (0..n-1)  
  - `adj`: adjacency list, where `adj[u]` is a list of `(v, w)` edges `u -> v`  
  - `source`: source node  
  Returns `(dist, prev)`, where `dist[v]` is the distance from `source` to `v` (or `math.inf` if unreachable), and `prev[v]` stores the predecessor of `v`. All edge weights `w` must be non-negative.

- `reconstruct_path(prev, s, t)`  
  Rebuilds the path `s -> t` using the `prev` array returned by `dijkstra`.  
  Returns a list of nodes, or `None` if `t` is unreachable.

- `matrix_to_adj(cost_matrix)`  
  Converts the `numpy` cost matrix produced by `create_problem(...)` (with `np.inf` meaning “no edge”) into the adjacency list format required by `dijkstra`.

- `all_pairs_dijkstra_with_handwritten(problem)`  
  Runs the handwritten Dijkstra from every node as source on the given cost matrix `problem`, and returns a list of tuples `(s, t, path, cost)` for all `0 <= s < t < n`.

Example usage:

```python
problem = create_problem(
    size=10,
    density=0.5,
    noise_level=0.0,
    negative_values=False,  # must be non-negative for Dijkstra
    seed=42,
)

results = all_pairs_dijkstra_with_handwritten(problem)
